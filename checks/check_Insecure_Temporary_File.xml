<?xml version="1.0" encoding="UTF-8"?>
<check status="enabled">
    <name><![CDATA[Insecure Temporary File]]></name>
    <description><![CDATA[Creating and using insecure temporary files can leave application and system data vulnerable to attacks.]]></description>
    <explanation><![CDATA[Applications require temporary files so frequently that many different mechanisms exist for creating them. Most of these functions are vulnerable to various forms of attacks.

Example: The following code uses a temporary file for storing intermediate data gathered from the network before it is processed.

KF_CODE_EXAMPLE
...
try:
    tmp_filename = os.tempnam()
    tmp_file = open(tmp_filename, 'w')
    data = s.recv(4096)
    while True:
        more = s.recv(4096)
        tmp_file.write(more)
        if not more:
            break
except socket.timeout:
    errMsg = "Connection timed-out while connecting"
    self.logger.exception(errMsg)
    raise Exception
...

This otherwise unremarkable code is vulnerable to a number of different attacks because it relies on an insecure method for creating temporary files. The vulnerabilities introduced by this function and others are described in the following sections. The most egregious security problems related to temporary file creation have occurred on Unix-based operating systems, but Windows applications have parallel risks.

Methods and behaviors can vary between systems, but the fundamental risks introduced by each are reasonably constant. See the Recommendations section for information about safe core language functions and advice regarding a secure approach to creating temporary files.

The functions designed to aid in the creation of temporary files can be broken into two groups based on whether they simply provide a filename or actually open a new file.

Group 1 - "Unique" Filenames:

The first group of functions designed to help with the process of creating temporary files do so by generating a unique file name for a new temporary file, which the program is then supposed to open. This group of functions suffers from an underlying race condition on the filename chosen. Although the functions guarantee that the filename is unique at the time it is selected, there is no mechanism to prevent another process or an attacker from creating a file with the same name after it is selected but before the application attempts to open the file. Beyond the risk of a legitimate collision caused by another call to the same function, there is a high probability that an attacker will be able to create a malicious collision because the filenames generated by these functions are not sufficiently randomized to make them difficult to guess.

If a file with the selected name is created, then depending on how the file is opened the existing contents or access permissions of the file may remain intact. If the existing contents of the file are malicious in nature, an attacker may be able to inject dangerous data into the application when it reads data back from the temporary file. If an attacker pre-creates the file with relaxed access permissions, then data stored in the temporary file by the application may be accessed, modified or corrupted by an attacker. On Unix based systems an even more insidious attack is possible if the attacker pre-creates the file as a link to another important file. Then, if the application truncates or writes data to the file, it may unwittingly perform damaging operations for the attacker. This is an especially serious threat if the program operates with elevated permissions.

Finally, in the best case the file will be opened with a call to open() using the os.O_CREAT and os.O_EXCL flags, which will fail if the file already exists and therefore prevent the types of attacks described previously. However, if an attacker is able to accurately predict a sequence of temporary file names, then the application may be prevented from opening necessary temporary storage causing a denial of service (DoS) attack. This type of attack would not be difficult to mount given the small amount of randomness used in the selection of the filenames generated by these functions.

Group 2 - "Unique" Files:

The second group of functions attempts to resolve some of the security problems related to temporary files by not only generating a unique file name, but also opening the file. This group includes functions like tmpfile().

The tmpfile() style functions construct a unique filename and open it in the same way that open() would if passed the flags "wb+", that is, as a binary file in read/write mode. If the file already exists, tmpfile() will truncate it to size zero, possibly in an attempt to assuage the security concerns mentioned earlier regarding the race condition that exists between the selection of a supposedly unique filename and the subsequent opening of the selected file. However, this behavior clearly does not solve the function's security problems. First, an attacker may pre-create the file with relaxed access-permissions that will likely be retained by the file opened by tmpfile(). Furthermore, on Unix based systems if the attacker pre-creates the file as a link to another important file, the application may use its possibly elevated permissions to truncate that file, thereby doing damage on behalf of the attacker. Finally, if tmpfile() does create a new file, the access permissions applied to that file will vary from one operating system to another, which can leave application data vulnerable even if an attacker is unable to predict the filename to be used in advance.]]></explanation>
    <severity>Low</severity>
    <recommendations>Use of this function may introduce a security hole in your program. By the time you get around to doing anything with the file name it returns, someone else may have beaten you to the punch. mktemp() usage can be replaced easily with NamedTemporaryFile(), passing it the delete=False parameter: f = NamedTemporaryFile(delete=False)</recommendations>
    <links><![CDATA[[1] B. Schneier Yarrow: A secure pseudorandom number generator (http://www.schneier.com/yarrow.html)
[2] Python Library Reference: os Python (https://docs.python.org/2/library/os.html)
[3] Python Library Reference: tempfile Python (https://docs.python.org/2/library/tempfile.html)
[4] Symlink race WikiPedia (http://en.wikipedia.org/wiki/Symlink_race)
[5] Time of check to time of use WikiPedia (http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
[6] Standards Mapping - Common Weakness Enumeration CWE ID 377
[7] Standards Mapping - DISA Control Correlation Identifier Version 2 CCI-001090
[8] Standards Mapping - General Data Protection Regulation (GDPR) Indirect Access to Sensitive Data
[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 SC-4 Information in Shared Resources (P1)
[10] Standards Mapping - NIST Special Publication 800-53 Revision 5 SC-4 Information in Shared System Resources
[11] Standards Mapping - Security Technical Implementation Guide Version 4.1 APSC-DV-002380 CAT II
[12] Standards Mapping - Security Technical Implementation Guide Version 4.2 APSC-DV-002380 CAT II
[13] Standards Mapping - Security Technical Implementation Guide Version 4.3 APSC-DV-002380 CAT II
[14] Standards Mapping - Security Technical Implementation Guide Version 4.4 APSC-DV-002380 CAT II
[15] Standards Mapping - Security Technical Implementation Guide Version 4.5 APSC-DV-002380 CAT II
[16] Standards Mapping - Security Technical Implementation Guide Version 4.6 APSC-DV-002380 CAT II
[17] Standards Mapping - Security Technical Implementation Guide Version 4.7 APSC-DV-002380 CAT II
[18] Standards Mapping - Security Technical Implementation Guide Version 4.8 APSC-DV-002380 CAT II
[19] Standards Mapping - Security Technical Implementation Guide Version 4.9 APSC-DV-002380 CAT II
[20] Standards Mapping - Security Technical Implementation Guide Version 4.10 APSC-DV-002380 CAT II
[21] Standards Mapping - Security Technical Implementation Guide Version 4.11 APSC-DV-002380 CAT II
[22] Standards Mapping - Security Technical Implementation Guide Version 5.1 APSC-DV-002380 CAT II
]]></links>
    <patterns>
        <pattern_simple>
            <function_call>
                <name operator="eq">tempfile.mktemp</name>
            </function_call>
        </pattern_simple>
    </patterns>
</check>
